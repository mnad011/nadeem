package ptolemy;
/* Generated by Ptolemy II (http://ptolemy.eecs.berkeley.edu)
Copyright (c) 2005-2009 The Regents of the University of California.
All rights reserved.
Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies
of this software.
IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.
*/
public class LightFollower {
    /* Generate type resolution code for .LightFollower */
    // ConstantsBlock from codegen/java/kernel/SharedCode.j
    private final short TYPE_Token = -1;
    // #define PTCG_TYPE_Double 0
    private final short TYPE_Double = 0;
    // #define PTCG_TYPE_Array 1
    private final short TYPE_Array = 1;
    // #define PTCG_TYPE_Integer 2
    private final short TYPE_Integer = 2;
    // #define PTCG_TYPE_Boolean 3
    private final short TYPE_Boolean = 3;
    // #define FUNC_new 0
    // #define FUNC_isCloseTo 1
    // #define FUNC_delete 2
    // #define FUNC_convert 3
    // java/kernel/type/Array.j
    public class array {
        public int size;
        public Token [] elements;
    }
    // Definition of the array struct.
    //struct array {
        //    int size;                                   // size of the array.
        //    Token* elements;                            // array of Token elements.
        //    //char elementType;                          // type of the elements.
    //};
    //typedef struct array* ArrayToken;
    public class Token {
        private Short type;
        Object payload;
    public Token() {};
        public Short getType() {
            return type;
        }
        public Object getPayload() {
            return payload;
        }
        /* DoubleToken Double;
        ArrayToken Array;
        IntegerToken Integer;
        BooleanToken Boolean;
        */
    }
    Token emptyToken; /* Used by *_delete() and others. */
    // Token Double_new (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Double_isCloseTo (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Double_convert (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Array_new (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Array_isCloseTo (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Array_delete (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Array_convert (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Integer_new (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Integer_isCloseTo (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Integer_convert (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Boolean_new (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Boolean_equals (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Boolean_isCloseTo (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Boolean_convert (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    /* We share one method between all scalar types so as to reduce code size. */
    Token scalarDelete(Token token, Token... tokens) {
        /* We need to return something here because all the methods are declared
        * as returning a Token so we can use them in a table of functions.
        */
        return emptyToken;
    }
    // Array_get: get an element of an array.
    Token Array_get(Token array, int i) {
        //return array.payload.Array->elements[i];
        return ((array)(array.payload)).elements[i];
    }
    // Array_set: set an element of an array.
    void Array_set(Token array, int i, Token element) {
        //array.payload.Array->elements[i] = element;
        ((array)(array.payload)).elements[i] = element;
    }
    // Array_resize: Change the size of an array,
    // preserving those elements that fit.
    void Array_resize(Token array, int size) {
        //array.payload.Array->size = size;
        // FIXME: Does realloc() initialize memory? If not, then we need to do that.
        //array.payload.Array->elements = (Token*) realloc(array.payload.Array->elements, size * sizeof(Token));
    }
    // Array_insert: Append the specified element to the end of an array.
    void Array_insert(Token array, Token token) {
        //int oldSize = array.payload.Array->size++;
        //Array_resize(array, array.payload.Array->size);
        //array.payload.Array->elements[oldSize] = token;
    }
    int Array_length(Token array) {
        return ((array)(array.payload)).size;
    }
    Integer StringtoInteger(String string) {
        return Integer.valueOf(string);
    }
    Long StringtoLong(String string) {
        return Long.valueOf(string);
    }
    Integer DoubletoInteger(Double d) {
        return Integer.valueOf((int)Math.floor(d.doubleValue()));
    }
    Double IntegertoDouble(Integer i) {
        return Double.valueOf(i.doubleValue());
    }
    Long IntegertoLong(int i) {
        return Long.valueOf(i);
    }
    String IntegertoString(int i) {
        return Integer.toString(i);
    }
    String LongtoString(long l) {
        return Long.toString(l);
    }
    String DoubletoString(double d) {
        return Double.toString(d);
    }
    String BooleantoString(boolean b) {
        return Boolean.toString(b);
    }
    String UnsignedBytetoString(byte b) {
        return Byte.toString(b);
    }
    private final int NUM_TYPE = 4;
    private final int NUM_FUNC = 4;
    //Token (*functionTable[NUM_TYPE][NUM_FUNC])(Token, ...)= {
    //	{Double_new, Double_isCloseTo, scalarDelete, Double_convert},
    //	{Array_new, Array_isCloseTo, Array_delete, Array_convert},
    //	{Integer_new, Integer_isCloseTo, scalarDelete, Integer_convert},
    //	{Boolean_new, Boolean_equals, scalarDelete, Boolean_convert}
    //};
    int multiply_Integer_Integer(int a1, int a2) {
        return a1 * a2;
    }
    int convert_Integer_Integer(int a) {
        return a;
    }
    int add_Integer_Integer(int a1, int a2) {
        return a1 + a2;
    }
    // make a new integer token from the given value.
    Token Integer_new(int i) {
        Token result = new Token();
        result.type = TYPE_Integer;
        result.payload = Integer.valueOf(i);
        return result;
    }
    // Array_new: Create a new array with the specified elements.
    // The "size" argument specifies the size of the array, and
    // the "given" argument specifies the number of provided elements
    // (which will typically be <= size).
    // The rest of the arguments are the provided elements (there
    // should be "given" of them). The given elements
    // should be of type Token.
    // The last element is the type, which is why this takes Object...
    // and not Token...
    Token Array_new(int size, int given, Object... elements) {
        int i;
        Token result = new Token();
        int elementType;
        array array = new array();
        array.size = size;
        array.elements = new Token[size];
        result.type = TYPE_Array;
        result.payload = array;
        if (size > 0 && given > 0) {
            for (i = 0; i < given; i++) {
                array.elements[i] = (Token)elements[i];
            }
            // elementType is given as the last argument.
            elementType = (Short)elements[i];
            if (elementType >= 0) {
                // convert the elements if needed.
                for (int j = 0; j < given; j++) {
                    if (Array_get(result, j).type != elementType) {
                        //Array_set(result, j, functionTable[(int)elementType][FUNC_convert](Array_get(result, j)));
                        switch(elementType) {
                            case TYPE_Array:
                            System.out.println("Array_new on an array of arrays, possible problem");
                            break;
                            case TYPE_Token:
                            Array_set(result, j, Array_get(result,j));
                            break;
                            // #ifdef PTCG_TYPE_Double
                            case TYPE_Double:
                            Array_set(result, j, Double_convert(Array_get(result,j)));
                            break;
                            // #endif
                            // #ifdef PTCG_TYPE_Integer
                            case TYPE_Integer:
                            Array_set(result, j, Integer_convert(Array_get(result,j)));
                            break;
                            // #endif
                            default:
                            throw new RuntimeException("Array_new(): Conversion from an unsupported type: "
                            +  elementType);
                        }
                    }
                }
            }
        }
        return result;
    }
    // make a new integer token from the given value.
    Token Double_new(double d) {
        Token result = new Token();
        result.type = TYPE_Double;
        result.payload = Double.valueOf(d);
        return result;
    }
    Token Double_isCloseTo(Token thisToken, Token... tokens) {
        Token otherToken;
        Token tolerance;
        otherToken = tokens[0];
        tolerance = tokens[0];
        return Boolean_new(Math.abs((Double)thisToken.payload - (Double)otherToken.payload) < (Double)tolerance.payload);
    }
    /* Instead of Double_delete(), we call scalarDelete(). */
    Token Double_convert(Token token, Token... elements) {
        switch (token.type) {
            // #ifdef PTCG_TYPE_String
            //    case TYPE_String:
            //        // FIXME: Is this safe?
            //        token.type = TYPE_Double;
            //        token.payload = ((Double)(token.payload)).toString();
            //        return token;
            // #endif
            // #ifdef PTCG_TYPE_Integer
            case TYPE_Integer:
            token.type = TYPE_Double;
            token.payload = IntegertoDouble((Integer)(token.payload));
            return token;
            // #endif
            case TYPE_Double:
            return token;
            // FIXME: not finished
            default:
            throw new RuntimeException("Double_convert(): Conversion from an unsupported type.: " + token.type);
        }
    }
    boolean isCloseTo_Token_Token(Token thisToken, Token otherToken, Token tolerance) {
        boolean result = false;
        if (thisToken.payload instanceof Number
        && thisToken.payload instanceof Number
        && tolerance.payload instanceof Number) {
            result =
            Math.abs((((Number)(thisToken.payload)).doubleValue() - ((Number)(otherToken.payload)).doubleValue())) < ((Number)(tolerance.payload)).doubleValue();
        } else if (thisToken.type == TYPE_Array
        && otherToken.type == TYPE_Array) {
            return ((Boolean)(Array_isCloseTo(thisToken, otherToken, tolerance).payload)).booleanValue();
            // #ifdef PTCG_TYPE_Matrix
        //    } else if (thisToken.type == TYPE_Matrix
        //               && otherToken.type == TYPE_Matrix) {
            //        return ((Boolean)(Matrix_isCloseTo(thisToken, otherToken, tolerance).payload)).booleanValue();
            // #endif
        } else {
            throw new InternalError("equals_Token_Token_(): iscloseTo with an unsupported type. " + thisToken.type + " " + otherToken.type + " " + tolerance.type);
        }
        return result;
    }
    // Array_isCloseTo: Test an array to see whether it is close in value to another.
    Token Array_isCloseTo(Token thisToken, Token... elements) {
        int i;
        Token otherToken = elements[0];
        Token tolerance = elements[1];
        if ( ((array)(thisToken.payload)).size != ((array)(otherToken.payload)).size) {
            //System.out.println("Array_isCloseTo sizes different:" + ((array)(thisToken.payload)).size + " "
            //                   + ((array)(otherToken.payload)).size);
            //print_Token3(thisToken);
            //print_Token3(otherToken);
            return Boolean_new(false);
        }
        for (i = 0; i < ((array)(thisToken.payload)).size; i++) {
            //System.out.println("Array_isCloseTo " + i);
            //print_Token3(Array_get(thisToken, i));
            //print_Token3(Array_get(otherToken, i));
            if (!isCloseTo_Token_Token(Array_get(thisToken, i), Array_get(otherToken, i), tolerance)) {
                return Boolean_new(false);
            }
        }
        return Boolean_new(true);
    }
    // Array_delete: FIXME: What does this do?
    Token Array_delete(Token token, Object... elements) {
        int i;
        Token element;
        // Delete each elements.
        for (i = 0; i < ((array)(token.payload)).size; i++) {
            element = Array_get(token, i);
            System.out.println("Array_delete: convert needs work");
            //functionTable[(int)element.type][FUNC_delete](element);
        }
        //free(token.payload.Array->elements);
        //free(token.payload.Array);
        /* We need to return something here because all the methods are declared
        * as returning a Token so we can use them in a table of functions.
        */
        return null;
    }
    // Array_convert: Convert the first argument array
    // into the type specified by the second argument.
    // @param token The token to be converted.
    // @param targetType The type to convert the elements of the given token to.
    Token Array_convert(Token token, Short... targetTypes) {
        int i;
        Token result;
        Token element;
        Short targetType;
        targetType = targetTypes[0];
        result = Array_new(((array)token.payload).size, 0);
        for (i = 0; i < ((array)token.payload).size; i++) {
            element = Array_get(token, i);
            if (targetType != element.type) {
                //result.payload.Array->elements[i] = functionTable[(int)targetType][FUNC_convert](element);
                switch (targetType) {
                    // #ifdef PTCG_TYPE_String
                    //            case TYPE_String:
                    //                    element = String_convert(element);
                    //            break;
                    // #endif
                    // #ifdef PTCG_TYPE_Integer
                    case TYPE_Integer:
                    element = Integer_convert(element);
                    break;
                    // #endif
                    // #ifdef PTCG_TYPE_Double
                    case TYPE_Double:
                    element = Double_convert(element);
                    break;
                    // #endif
                    case TYPE_Array:
                    element = Array_convert(element, targetType);
                    break;
                    default:
                    throw new RuntimeException("Array_convert(): Conversion from an unsupported type: " + targetType);
                }
                ((array)(result.payload)).elements[i] = element;
            } else {
                ((array)(result.payload)).elements[i] = element;
            }
        }
        return result;
    }
    Token Integer_isCloseTo(Token thisToken, Token... tokens) {
        Token otherToken;
        Token tolerance;
        otherToken = tokens[0];
        tolerance = tokens[1];
        return Boolean_new(Math.abs((Integer)thisToken.payload - (Integer)otherToken.payload) < (Double)tolerance.payload);
    }
    /* Instead of Integer_delete(), we call scalarDelete(). */
    Token Integer_convert(Token token, Token... elements) {
        token.type = TYPE_Integer;
        switch (token.type) {
            // #ifdef PTCG_TYPE_Double
            case TYPE_Double:
            token.payload = DoubletoInteger((Double)token.payload);
            return token;
            // #endif
            case TYPE_Integer:
            return token;
            // FIXME: not finished
            default:
            throw new RuntimeException("Integer_convert(): Conversion from an unsupported type: "
            + token.type);
        }
    }
    // make a new integer token from the given value.
    Token Boolean_new(boolean b) {
        Token result = new Token();
        result.type = TYPE_Boolean;
        result.payload = Boolean.valueOf(b);
        return result;
    }
    Token Boolean_equals(Token thisToken, Token... tokens) {
        Token otherToken;
        otherToken = tokens[0];
        return Boolean_new(
        ( (Boolean)thisToken.payload && (Boolean)otherToken.payload ) ||
        ( !(Boolean)thisToken.payload && !(Boolean)otherToken.payload ));
    }
    /* Instead of Boolean_delete(), we call scalarDelete(). */
    Token Boolean_convert(Token token, Token... tokens) {
        switch (token.type) {
            case TYPE_Boolean:
            return token;
            default:
            throw new RuntimeException("Boolean_convert(): Conversion from an unsupported type.: " + token.type);
        }
    }
    /* Generate shared code for LightFollower */
    /* max and min may be used by the Expression actor. */
    // #ifndef max
    // #define max(a,b) ((a)>(b)?(a):(b))
    // #endif
    // #ifndef min
    // #define min(a,b) ((a)<(b)?(a):(b))
    // #endif
    /* Finished generating shared code for LightFollower */
    /* end shared code */
    /* LightFollower_RightWheel's referenced parameter declarations. */
    static int LightFollower_RightWheel_portAddress_;
    /* LightFollower_RightWheel's input variable declarations. */
    static int LightFollower_RightWheel_input;
    /* LightFollower_Expression's input variable declarations. */
    static int LightFollower_Expression_input;
    /* LightFollower_LightSensor's referenced parameter declarations. */
    static int LightFollower_LightSensor_portAddress_;
    /* LightFollower_Expression2's input variable declarations. */
    static int LightFollower_Expression2_input;
    /* LightFollower_Sequence's referenced parameter declarations. */
    static Token LightFollower_Sequence_values_;
    /* LightFollower_LeftWheel's referenced parameter declarations. */
    static int LightFollower_LeftWheel_portAddress_;
    /* LightFollower_LeftWheel's input variable declarations. */
    static int LightFollower_LeftWheel_input;
    /* LightFollower_Expression3's input variable declarations. */
    static int LightFollower_Expression3_input;
    /* LightFollower_Sequence2's referenced parameter declarations. */
    static Token LightFollower_Sequence2_values_;
    /* LightFollower_AddSubtract's input variable declarations. */
    static int LightFollower_AddSubtract_plus[] = new int[2];
    /* LightFollower_AddSubtract2's input variable declarations. */
    static int LightFollower_AddSubtract2_plus[] = new int[2];
    /* LightFollower_FSMActor's input variable declarations. */
    static int LightFollower_FSMActor_input;
    /* LightFollower_Discard's input variable declarations. */
    static int LightFollower_Discard_input[] = new int[1];
    /* Provide the period attribute as constant. */
    public final static double PERIOD = 0.25;
    /* Provide the iteration count. */
    public static int _iteration = 0;
    /* The preinitialization of the director. */
    /* preinitRightWheel */
    int LightFollower_RightWheel___val = 0;
    int LightFollower_RightWheel___last_val;
    /* preinitExpression */
    static int LightFollower_Expression__iterationCount = 1;
    /* preinitLightSensor */
    boolean LightFollower_LightSensor___firstFire = true;
    /* preinitExpression2 */
    static int LightFollower_Expression2__iterationCount = 1;
    /* preinitSequence */
    int LightFollower_Sequence__currentIndex = 0;
    boolean LightFollower_Sequence__outputProduced = false;
    /* preinitLeftWheel */
    int LightFollower_LeftWheel___val = 0;
    int LightFollower_LeftWheel___last_val;
    /* preinitExpression3 */
    static int LightFollower_Expression3__iterationCount = 1;
    /* preinitSequence2 */
    int LightFollower_Sequence2__currentIndex = 0;
    boolean LightFollower_Sequence2__outputProduced = false;
    /* preinitialize AddSubtract */
    int LightFollower_AddSubtract__result;
    /* preinitialize AddSubtract2 */
    int LightFollower_AddSubtract2__result;
    /* preinitFSMActor */
    static int LightFollower_FSMActor__currentState;
    static char LightFollower_FSMActor__transitionFlag;
    final static int STATE_LightFollower_FSMActor_DriveForward = 0;
    final static int STATE_LightFollower_FSMActor_DriveLeft = 1;
    final static int STATE_LightFollower_FSMActor_DriveRight = 2;
    /* end preinitialize code */
    /* before appending fireFunctionCode */
    void LightFollower_RightWheel() {
        LightFollower_RightWheel___last_val = LightFollower_RightWheel___val;
        // no check on available input token here - so above assignment is useless
        LightFollower_RightWheel___last_val = LightFollower_RightWheel_input;
    }
    void LightFollower_Expression() {
        LightFollower_RightWheel_input = (add_Integer_Integer(convert_Integer_Integer((multiply_Integer_Integer(multiply_Integer_Integer(LightFollower_Expression_input, 4), 1000))), 2));
    }
    void LightFollower_LightSensor() {
        if (LightFollower_LightSensor___firstFire) {
            // read the value
            LightFollower_Expression2_input = com.jopdesign.sys.Native.rdMem(LightFollower_LightSensor_portAddress_);
            LightFollower_LightSensor___firstFire = false;
        }
    }
    void LightFollower_Expression2() {
        LightFollower_Discard_input[0] = (LightFollower_Expression2_input%512);
    }
    void LightFollower_Sequence() {
        if (LightFollower_Sequence__currentIndex < 18) {
            LightFollower_AddSubtract_plus[1] = ((Integer)(/*JCGH44*/Array_get(LightFollower_Sequence_values_ , LightFollower_Sequence__currentIndex).payload/*jcgh2*/)).intValue();
            LightFollower_Sequence__outputProduced = true;
        };
        if (LightFollower_Sequence__outputProduced) {
            LightFollower_Sequence__outputProduced = false;
            LightFollower_Sequence__currentIndex += 1;
            if (LightFollower_Sequence__currentIndex >= 18) {
                if (true) {
                    // Code for the case where repeat is true
                    LightFollower_Sequence__currentIndex = 0;
                } else {
                    // Code for the case where repeat is false
                    //To prevent overflow...
                    LightFollower_Sequence__currentIndex = 18;
                }
            }
        }
    }
    void LightFollower_LeftWheel() {
        LightFollower_LeftWheel___last_val = LightFollower_LeftWheel___val;
        // no check on available input token here - so above assignment is useless
        LightFollower_LeftWheel___last_val = LightFollower_LeftWheel_input;
    }
    void LightFollower_Expression3() {
        LightFollower_LeftWheel_input = (add_Integer_Integer(convert_Integer_Integer((multiply_Integer_Integer(multiply_Integer_Integer(LightFollower_Expression3_input, 4), 1000))), 1));
    }
    void LightFollower_Sequence2() {
        if (LightFollower_Sequence2__currentIndex < 18) {
            LightFollower_AddSubtract2_plus[1] = ((Integer)(/*JCGH44*/Array_get(LightFollower_Sequence2_values_ , LightFollower_Sequence2__currentIndex).payload/*jcgh2*/)).intValue();
            LightFollower_Sequence2__outputProduced = true;
        };
        if (LightFollower_Sequence2__outputProduced) {
            LightFollower_Sequence2__outputProduced = false;
            LightFollower_Sequence2__currentIndex += 1;
            if (LightFollower_Sequence2__currentIndex >= 18) {
                if (true) {
                    // Code for the case where repeat is true
                    LightFollower_Sequence2__currentIndex = 0;
                } else {
                    // Code for the case where repeat is false
                    //To prevent overflow...
                    LightFollower_Sequence2__currentIndex = 18;
                }
            }
        }
    }
    void LightFollower_AddSubtract() {
        LightFollower_AddSubtract__result = convert_Integer_Integer(LightFollower_AddSubtract_plus[0]);
        LightFollower_AddSubtract__result = add_Integer_Integer(LightFollower_AddSubtract__result, LightFollower_AddSubtract_plus[1]);
        LightFollower_Expression_input = LightFollower_AddSubtract__result;
    }
    void LightFollower_AddSubtract2() {
        LightFollower_AddSubtract2__result = convert_Integer_Integer(LightFollower_AddSubtract2_plus[0]);
        LightFollower_AddSubtract2__result = add_Integer_Integer(LightFollower_AddSubtract2__result, LightFollower_AddSubtract2_plus[1]);
        LightFollower_Expression3_input = LightFollower_AddSubtract2__result;
    }
    void LightFollower_FSMActor() {
        LightFollower_FSMActor__transitionFlag = 1;
        switch (LightFollower_FSMActor__currentState) {
            case STATE_LightFollower_FSMActor_DriveForward:
            if ((LightFollower_FSMActor_input > 0)) {
                LightFollower_AddSubtract2_plus[0] = 5;
                LightFollower_AddSubtract_plus[0] = 0;
                LightFollower_FSMActor__currentState = STATE_LightFollower_FSMActor_DriveRight;
            } else if ((LightFollower_FSMActor_input < 0)) {
                LightFollower_AddSubtract_plus[0] = 5;
                LightFollower_AddSubtract2_plus[0] = 0;
                LightFollower_FSMActor__currentState = STATE_LightFollower_FSMActor_DriveLeft;
            } else if ((LightFollower_FSMActor_input == 0)) {
                LightFollower_AddSubtract_plus[0] = 5;
                LightFollower_AddSubtract2_plus[0] = 5;
                LightFollower_FSMActor__currentState = STATE_LightFollower_FSMActor_DriveForward;
            } else {
                LightFollower_FSMActor__transitionFlag = 0;
            }
            break;
            case STATE_LightFollower_FSMActor_DriveLeft:
            if ((LightFollower_FSMActor_input >= 0)) {
                LightFollower_FSMActor__currentState = STATE_LightFollower_FSMActor_DriveForward;
            } else {
                LightFollower_FSMActor__transitionFlag = 0;
            }
            break;
            case STATE_LightFollower_FSMActor_DriveRight:
            if ((LightFollower_FSMActor_input <= 0)) {
                LightFollower_FSMActor__currentState = STATE_LightFollower_FSMActor_DriveForward;
            } else {
                LightFollower_FSMActor__transitionFlag = 0;
            }
            break;
        }
    }
    void LightFollower_Const() {
        LightFollower_FSMActor_input = -1;
    }
    void LightFollower_Discard() {
        // consume the input token.
        ;
        //LightFollower_Discard_input[0];
    }
    /* Skipping creating top level here, thus avoiding duplicated code. */
    /* after appending fireFunctionCode */
    public void initialize() {
        /* RightWheel's parameter initialization */
        LightFollower_RightWheel_portAddress_ = -79;
        /* LightSensor's parameter initialization */
        LightFollower_LightSensor_portAddress_ = -80;
        /* Sequence's parameter initialization */
        LightFollower_Sequence_values_ = Array_new(18, 18, Integer_new(0), Integer_new(1), Integer_new(2), Integer_new(3), Integer_new(4), Integer_new(5), Integer_new(6), Integer_new(7), Integer_new(8), Integer_new(9), Integer_new(8), Integer_new(7), Integer_new(6), Integer_new(5), Integer_new(4), Integer_new(3), Integer_new(2), Integer_new(1), TYPE_Integer);
        /* LeftWheel's parameter initialization */
        LightFollower_LeftWheel_portAddress_ = -78;
        /* Sequence2's parameter initialization */
        LightFollower_Sequence2_values_ = Array_new(18, 18, Integer_new(9), Integer_new(8), Integer_new(7), Integer_new(6), Integer_new(5), Integer_new(4), Integer_new(3), Integer_new(2), Integer_new(1), Integer_new(0), Integer_new(1), Integer_new(2), Integer_new(3), Integer_new(4), Integer_new(5), Integer_new(6), Integer_new(7), Integer_new(8), TYPE_Integer);
        /* The initialization of the director. */
        LightFollower_FSMActor__currentState = STATE_LightFollower_FSMActor_DriveForward;
    }
    public void wrapup() {
        /* The wrapup of the director. */
    }
    public static void main(String [] args) throws Exception {
        LightFollower model = new LightFollower();
        model.initialize();
        model.execute();
        model.doWrapup();
        System.exit(0);
    }
    // Don't call initialize() here, it is called in main.
    public void execute() throws Exception {
        int iteration;
        for (iteration = 0; iteration < 20; iteration ++) {
            run();
        }
    }
    public void run() throws Exception {
        /* The firing of the StaticSchedulingDirector */
        LightFollower_Const();
        /* ....Begin updateOffset....LightFollower_Const_trigger */
        /*
        ....Begin updateConnectedPortsOffset....LightFollower_Const_output */
        /*
        ....End updateConnectedPortsOffset....LightFollower_Const_output */
        LightFollower_FSMActor();
        /* ....Begin updateOffset....LightFollower_FSMActor_input */
        /*
        ....End updateOffset....LightFollower_FSMActor_input */
        /*
        ....Begin updateConnectedPortsOffset....LightFollower_FSMActor_right */
        /*
        ....End updateConnectedPortsOffset....LightFollower_FSMActor_right */
        /*
        ....Begin updateConnectedPortsOffset....LightFollower_FSMActor_left */
        /*
        ....End updateConnectedPortsOffset....LightFollower_FSMActor_left */
        LightFollower_Sequence2();
        /* ....Begin updateOffset....LightFollower_Sequence2_enable */
        /*
        ....Begin updateConnectedPortsOffset....LightFollower_Sequence2_output */
        /*
        ....End updateConnectedPortsOffset....LightFollower_Sequence2_output */
        LightFollower_AddSubtract2();
        /* ....Begin updateOffset....LightFollower_AddSubtract2_plus */
        /*
        ....End updateOffset....LightFollower_AddSubtract2_plus */
        /*
        ....End updateOffset....LightFollower_AddSubtract2_plus */
        /* ....Begin updateOffset....LightFollower_AddSubtract2_minus */
        /*
        ....Begin updateConnectedPortsOffset....LightFollower_AddSubtract2_output */
        /*
        ....End updateConnectedPortsOffset....LightFollower_AddSubtract2_output */
        LightFollower_Expression3();
        /* ....Begin updateOffset....LightFollower_Expression3_input */
        /*
        ....End updateOffset....LightFollower_Expression3_input */
        /*
        ....Begin updateConnectedPortsOffset....LightFollower_Expression3_output */
        /*
        ....End updateConnectedPortsOffset....LightFollower_Expression3_output */
        LightFollower_LeftWheel();
        /* ....Begin updateOffset....LightFollower_LeftWheel_input */
        /*
        ....End updateOffset....LightFollower_LeftWheel_input */
        LightFollower_Sequence();
        /* ....Begin updateOffset....LightFollower_Sequence_enable */
        /*
        ....Begin updateConnectedPortsOffset....LightFollower_Sequence_output */
        /*
        ....End updateConnectedPortsOffset....LightFollower_Sequence_output */
        LightFollower_AddSubtract();
        /* ....Begin updateOffset....LightFollower_AddSubtract_plus */
        /*
        ....End updateOffset....LightFollower_AddSubtract_plus */
        /*
        ....End updateOffset....LightFollower_AddSubtract_plus */
        /* ....Begin updateOffset....LightFollower_AddSubtract_minus */
        /*
        ....Begin updateConnectedPortsOffset....LightFollower_AddSubtract_output */
        /*
        ....End updateConnectedPortsOffset....LightFollower_AddSubtract_output */
        LightFollower_Expression();
        /* ....Begin updateOffset....LightFollower_Expression_input */
        /*
        ....End updateOffset....LightFollower_Expression_input */
        /*
        ....Begin updateConnectedPortsOffset....LightFollower_Expression_output */
        /*
        ....End updateConnectedPortsOffset....LightFollower_Expression_output */
        LightFollower_RightWheel();
        /* ....Begin updateOffset....LightFollower_RightWheel_input */
        /*
        ....End updateOffset....LightFollower_RightWheel_input */
        LightFollower_LightSensor();
        /* ....Begin updateOffset....LightFollower_LightSensor_trigger */
        /*
        ....Begin updateConnectedPortsOffset....LightFollower_LightSensor_output */
        /*
        ....End updateConnectedPortsOffset....LightFollower_LightSensor_output */
        LightFollower_Expression2();
        /* ....Begin updateOffset....LightFollower_Expression2_input */
        /*
        ....End updateOffset....LightFollower_Expression2_input */
        /*
        ....Begin updateConnectedPortsOffset....LightFollower_Expression2_output */
        /*
        ....End updateConnectedPortsOffset....LightFollower_Expression2_output */
        LightFollower_Discard();
        /* ....Begin updateOffset....LightFollower_Discard_input */
        /*
        ....End updateOffset....LightFollower_Discard_input */
        /* The postfire of the director. */
        LightFollower_RightWheel___val = LightFollower_RightWheel___last_val;
        com.jopdesign.sys.Native.wrMem(LightFollower_RightWheel___val, LightFollower_RightWheel_portAddress_);
        /* postfireExpression */
        LightFollower_Expression__iterationCount++;
        /* postfireLightSensor */
        LightFollower_LightSensor___firstFire = true;
        /* postfireExpression2 */
        LightFollower_Expression2__iterationCount++;
        LightFollower_LeftWheel___val = LightFollower_LeftWheel___last_val;
        com.jopdesign.sys.Native.wrMem(LightFollower_LeftWheel___val, LightFollower_LeftWheel_portAddress_);
        /* postfireExpression3 */
        LightFollower_Expression3__iterationCount++;
        ++_iteration;
    }
    public void doWrapup() throws Exception {
    }
}
