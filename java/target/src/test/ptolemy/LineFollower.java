package ptolemy;
/* Generated by Ptolemy II (http://ptolemy.eecs.berkeley.edu)
Copyright (c) 2005-2010 The Regents of the University of California.
All rights reserved.
Permission is hereby granted, without written agreement and without
license or royalty fees, to use, copy, modify, and distribute this
software and its documentation for any purpose, provided that the above
copyright notice and the following two paragraphs appear in all copies
of this software.
IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.
*/
public class LineFollower {
    /* Generate type resolution code for .LineFollower */
    // ConstantsBlock from codegen/java/kernel/SharedCode.j
    private final short TYPE_Token = -1;
    // #define PTCG_TYPE_Boolean 0
    private final short TYPE_Boolean = 0;
    // #define FUNC_new 0
    // #define FUNC_isCloseTo 1
    // #define FUNC_delete 2
    // #define FUNC_convert 3
    public class Token {
        private Short type;
        Object payload;
    public Token() {};
        public Short getType() {
            return type;
        }
        public Object getPayload() {
            return payload;
        }
        /* BooleanToken Boolean;
        */
    }
    Token emptyToken; /* Used by *_delete() and others. */
    // Token Boolean_new (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Boolean_equals (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Boolean_isCloseTo (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    // Token Boolean_convert (Token thisToken, Token... tokens);  From codegen/java/kernel/SharedCode.j
    /* We share one method between all scalar types so as to reduce code size. */
    Token scalarDelete(Token token, Token... tokens) {
        /* We need to return something here because all the methods are declared
        * as returning a Token so we can use them in a table of functions.
        */
        return emptyToken;
    }
    Integer StringtoInteger(String string) {
        return Integer.valueOf(string);
    }
    Long StringtoLong(String string) {
        return Long.valueOf(string);
    }
    Integer DoubletoInteger(Double d) {
        return Integer.valueOf((int)Math.floor(d.doubleValue()));
    }
    Double IntegertoDouble(Integer i) {
        return Double.valueOf(i.doubleValue());
    }
    Long IntegertoLong(int i) {
        return Long.valueOf(i);
    }
    String IntegertoString(int i) {
        return Integer.toString(i);
    }
    String LongtoString(long l) {
        return Long.toString(l);
    }
    String DoubletoString(double d) {
        return Double.toString(d);
    }
    String BooleantoString(boolean b) {
        return Boolean.toString(b);
    }
    String UnsignedBytetoString(byte b) {
        return Byte.toString(b);
    }
    private final int NUM_TYPE = 1;
    private final int NUM_FUNC = 4;
    //Token (*functionTable[NUM_TYPE][NUM_FUNC])(Token, ...)= {
    //	{Boolean_new, Boolean_equals, scalarDelete, Boolean_convert}
    //};
    int multiply_Integer_Integer(int a1, int a2) {
        return a1 * a2;
    }
    int convert_Integer_Integer(int a) {
        return a;
    }
    int add_Integer_Integer(int a1, int a2) {
        return a1 + a2;
    }
    int subtract_Integer_Integer(int a1, int a2) {
        return a1 - a2;
    }
    // make a new integer token from the given value.
    Token Boolean_new(boolean b) {
        Token result = new Token();
        result.type = TYPE_Boolean;
        result.payload = Boolean.valueOf(b);
        return result;
    }
    Token Boolean_equals(Token thisToken, Token... tokens) {
        Token otherToken;
        otherToken = tokens[0];
        return Boolean_new(
        ( (Boolean)thisToken.payload && (Boolean)otherToken.payload ) ||
        ( !(Boolean)thisToken.payload && !(Boolean)otherToken.payload ));
    }
    /* Instead of Boolean_delete(), we call scalarDelete(). */
    Token Boolean_convert(Token token, Token... tokens) {
        switch (token.type) {
            case TYPE_Boolean:
            return token;
            default:
            throw new RuntimeException("Boolean_convert(): Conversion from an unsupported type.: " + token.type);
        }
    }
    /* Generate shared code for LineFollower */
    /* max and min may be used by the Expression actor. */
    // #ifndef max
    // #define max(a,b) ((a)>(b)?(a):(b))
    // #endif
    // #ifndef min
    // #define min(a,b) ((a)<(b)?(a):(b))
    // #endif
    /* Finished generating shared code for LineFollower */
    /* end shared code */
    /* LineFollower_RightWheel's referenced parameter declarations. */
    static int LineFollower_RightWheel_portAddress_;
    /* LineFollower_RightWheel's input variable declarations. */
    static int LineFollower_RightWheel_input;
    /* LineFollower_Expression's input variable declarations. */
    static int LineFollower_Expression_input;
    /* LineFollower_LightSensor's referenced parameter declarations. */
    static int LineFollower_LightSensor_portAddress_;
    /* LineFollower_Expression2's input variable declarations. */
    static int LineFollower_Expression2_input;
    /* LineFollower_LeftWheel's referenced parameter declarations. */
    static int LineFollower_LeftWheel_portAddress_;
    /* LineFollower_LeftWheel's input variable declarations. */
    static int LineFollower_LeftWheel_input;
    /* LineFollower_Expression3's input variable declarations. */
    static int LineFollower_Expression3_input;
    /* LineFollower_FSMActor's input variable declarations. */
    static int LineFollower_FSMActor_input;
    /* Provide the period attribute as constant. */
    public final static double PERIOD = 0.25;
    /* Provide the iteration count. */
    public static int _iteration = 0;
    /* The preinitialization of the director. */
    /* preinitRightWheel */
    int LineFollower_RightWheel___val = 0;
    int LineFollower_RightWheel___last_val;
    /* preinitExpression */
    static int LineFollower_Expression__iterationCount = 1;
    /* preinitLightSensor */
    boolean LineFollower_LightSensor___firstFire = true;
    /* preinitExpression2 */
    static int LineFollower_Expression2__iterationCount = 1;
    /* preinitLeftWheel */
    int LineFollower_LeftWheel___val = 0;
    int LineFollower_LeftWheel___last_val;
    /* preinitExpression3 */
    static int LineFollower_Expression3__iterationCount = 1;
    /* preinitFSMActor */
    static int LineFollower_FSMActor__currentState;
    static char LineFollower_FSMActor__transitionFlag;
    final static int STATE_LineFollower_FSMActor_DriveForward = 0;
    final static int STATE_LineFollower_FSMActor_DriveLeft = 1;
    final static int STATE_LineFollower_FSMActor_DriveRight = 2;
    /* end preinitialize code */
    /* before appending fireFunctionCode */
    void LineFollower_RightWheel() {
        LineFollower_RightWheel___last_val = LineFollower_RightWheel___val;
        // no check on available input token here - so above assignment is useless
        LineFollower_RightWheel___last_val = LineFollower_RightWheel_input;
    }
    void LineFollower_Expression() {
        LineFollower_RightWheel_input = (add_Integer_Integer(convert_Integer_Integer((multiply_Integer_Integer(multiply_Integer_Integer(LineFollower_Expression_input, 4), 1000))), 2));
    }
    void LineFollower_LightSensor() {
        if (LineFollower_LightSensor___firstFire) {
            // read the value
            LineFollower_Expression2_input = com.jopdesign.sys.Native.rdMem(LineFollower_LightSensor_portAddress_);
            LineFollower_LightSensor___firstFire = false;
        }
    }
    void LineFollower_Expression2() {
        LineFollower_FSMActor_input = (subtract_Integer_Integer(convert_Integer_Integer(LineFollower_Expression2_input), 250));
    }
    void LineFollower_LeftWheel() {
        LineFollower_LeftWheel___last_val = LineFollower_LeftWheel___val;
        // no check on available input token here - so above assignment is useless
        LineFollower_LeftWheel___last_val = LineFollower_LeftWheel_input;
    }
    void LineFollower_Expression3() {
        LineFollower_LeftWheel_input = (add_Integer_Integer(convert_Integer_Integer((multiply_Integer_Integer(multiply_Integer_Integer(LineFollower_Expression3_input, 4), 1000))), 1));
    }
    void LineFollower_FSMActor() {
        LineFollower_FSMActor__transitionFlag = 1;
        switch (LineFollower_FSMActor__currentState) {
            case STATE_LineFollower_FSMActor_DriveForward:
            if ((LineFollower_FSMActor_input > 0)) {
                LineFollower_Expression3_input = 5;
                LineFollower_Expression_input = 0;
                LineFollower_FSMActor__currentState = STATE_LineFollower_FSMActor_DriveRight;
            } else if ((LineFollower_FSMActor_input < 0)) {
                LineFollower_Expression_input = 5;
                LineFollower_Expression3_input = 0;
                LineFollower_FSMActor__currentState = STATE_LineFollower_FSMActor_DriveLeft;
            } else if ((LineFollower_FSMActor_input == 0)) {
                LineFollower_Expression_input = 5;
                LineFollower_Expression3_input = 5;
                LineFollower_FSMActor__currentState = STATE_LineFollower_FSMActor_DriveForward;
            } else {
                LineFollower_FSMActor__transitionFlag = 0;
            }
            break;
            case STATE_LineFollower_FSMActor_DriveLeft:
            if ((LineFollower_FSMActor_input >= 0)) {
                LineFollower_FSMActor__currentState = STATE_LineFollower_FSMActor_DriveForward;
            } else {
                LineFollower_FSMActor__transitionFlag = 0;
            }
            break;
            case STATE_LineFollower_FSMActor_DriveRight:
            if ((LineFollower_FSMActor_input <= 0)) {
                LineFollower_FSMActor__currentState = STATE_LineFollower_FSMActor_DriveForward;
            } else {
                LineFollower_FSMActor__transitionFlag = 0;
            }
            break;
        }
    }
    /* Skipping creating top level here, thus avoiding duplicated code. */
    /* after appending fireFunctionCode */
    public void initialize() {
        /* RightWheel's parameter initialization */
        LineFollower_RightWheel_portAddress_ = -79;
        /* LightSensor's parameter initialization */
        LineFollower_LightSensor_portAddress_ = -80;
        /* LeftWheel's parameter initialization */
        LineFollower_LeftWheel_portAddress_ = -78;
        /* The initialization of the director. */
        LineFollower_FSMActor__currentState = STATE_LineFollower_FSMActor_DriveForward;
    }
    public void wrapup() {
        /* The wrapup of the director. */
    }
    public static void main(String [] args) throws Exception {
        LineFollower model = new LineFollower();
        model.initialize();
        model.execute();
        model.doWrapup();
        System.exit(0);
    }
    // Don't call initialize() here, it is called in main.
    public void execute() throws Exception {
        int iteration;
        for (iteration = 0; iteration < 20; iteration ++) {
            run();
        }
    }
    public void run() throws Exception {
        /* The firing of the StaticSchedulingDirector */
        LineFollower_LightSensor();
        /* ....Begin updateOffset....LineFollower_LightSensor_trigger */
        /*
        ....Begin updateConnectedPortsOffset....LineFollower_LightSensor_output */
        /*
        ....End updateConnectedPortsOffset....LineFollower_LightSensor_output */
        LineFollower_Expression2();
        /* ....Begin updateOffset....LineFollower_Expression2_input */
        /*
        ....End updateOffset....LineFollower_Expression2_input */
        /*
        ....Begin updateConnectedPortsOffset....LineFollower_Expression2_output */
        /*
        ....End updateConnectedPortsOffset....LineFollower_Expression2_output */
        LineFollower_FSMActor();
        /* ....Begin updateOffset....LineFollower_FSMActor_input */
        /*
        ....End updateOffset....LineFollower_FSMActor_input */
        /*
        ....Begin updateConnectedPortsOffset....LineFollower_FSMActor_right */
        /*
        ....End updateConnectedPortsOffset....LineFollower_FSMActor_right */
        /*
        ....Begin updateConnectedPortsOffset....LineFollower_FSMActor_left */
        /*
        ....End updateConnectedPortsOffset....LineFollower_FSMActor_left */
        LineFollower_Expression();
        /* ....Begin updateOffset....LineFollower_Expression_input */
        /*
        ....End updateOffset....LineFollower_Expression_input */
        /*
        ....Begin updateConnectedPortsOffset....LineFollower_Expression_output */
        /*
        ....End updateConnectedPortsOffset....LineFollower_Expression_output */
        LineFollower_RightWheel();
        /* ....Begin updateOffset....LineFollower_RightWheel_input */
        /*
        ....End updateOffset....LineFollower_RightWheel_input */
        LineFollower_Expression3();
        /* ....Begin updateOffset....LineFollower_Expression3_input */
        /*
        ....End updateOffset....LineFollower_Expression3_input */
        /*
        ....Begin updateConnectedPortsOffset....LineFollower_Expression3_output */
        /*
        ....End updateConnectedPortsOffset....LineFollower_Expression3_output */
        LineFollower_LeftWheel();
        /* ....Begin updateOffset....LineFollower_LeftWheel_input */
        /*
        ....End updateOffset....LineFollower_LeftWheel_input */
        /* The postfire of the director. */
        LineFollower_RightWheel___val = LineFollower_RightWheel___last_val;
        com.jopdesign.sys.Native.wrMem(LineFollower_RightWheel___val, LineFollower_RightWheel_portAddress_);
        /* postfireExpression */
        LineFollower_Expression__iterationCount++;
        /* postfireLightSensor */
        LineFollower_LightSensor___firstFire = true;
        /* postfireExpression2 */
        LineFollower_Expression2__iterationCount++;
        LineFollower_LeftWheel___val = LineFollower_LeftWheel___last_val;
        com.jopdesign.sys.Native.wrMem(LineFollower_LeftWheel___val, LineFollower_LeftWheel_portAddress_);
        /* postfireExpression3 */
        LineFollower_Expression3__iterationCount++;
        ++_iteration;
    }
    public void doWrapup() throws Exception {
    }
}
