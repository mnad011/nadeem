package hwScopeEx.sensors;

import joprt.RtThread;

import com.jopdesign.sys.Memory;

public class Monitor {
	
	/*
	 * Use the simulated VHDL versions of the HW sensors, otherwhise
	 * random numbers are generated by the SW.
	 * 
	 * Status:
	 * - HW sensor M: A monitor HW sensor. It is possible to read only one 
	 * 				  constant value (Used for testing the use of HW objects)
	 * - HW sensor C: A calibration sensor object. As with HW sensor M, 
	 * 				  possible to read only a constant value  
	 */
	public static final boolean USE_HW_SENSORS = true;
	public static final int NO_OF_SENSORS = 250;
		
	static final int M_SIZE = 4096;
	static final int S_SIZE = 8192;
	
	static final int TIME_BASE = 1000;
	static final int FRAME_LENGTH = 10;
	
	static final int TS_PRIO = 14;
	
	static final int TS_PERIOD = 1;
	
	/*
	 * Constants to count reference access
	 */
	public static boolean COUNT_REF = false;
	public static int PUTFIELD_COUNT = 0;
	public static int PUTSTATIC_COUNT = 0;
	public static int AASTORE_COUNT = 0;
	
	// Sensor ID's
	static final int Asensor = 0;
	static final int Bsensor = 1;
	
	static final int SAMPLES = 20;
	
	/* An array holding two objects. each object has the results of the computations
	 * of each sensor. This array will be stored in an upper scope so we can test the
	 * use of the aastore bytecode
	 */
	// static fields located in immortal memory (level = 0)
	public static Calibration[] calibration = new Calibration[Monitor.NO_OF_SENSORS];
	public static Meassurements[] meassurements = new Meassurements[Monitor.NO_OF_SENSORS];
	
	public Environment E = new Environment();
	
	double t1,t2,time = 0;
	
	public void run() {
		
		for(int i = 0; i < Monitor.NO_OF_SENSORS; i++){
			meassurements[i] = new Meassurements();
			calibration[i] = new Calibration();
			//calibration[i].cal_param_1 = 10;
		}
		
		final SensorCalibrate sensorCalibrate = new SensorCalibrate(E,calibration);
		final SensorMeassure sensorMeassure = new SensorMeassure(E, meassurements, calibration);
				
			
			/* Nested scoped memory. It will be used to hold temporary objects
			 * such as the sensor objects and to perform temporary computations
			 * When the enterPrivate() method returns, we have the necessary
			 * information to take a decision (i.e. start some actuator)
			 */ 
			Memory m = Memory.getCurrentMemory();

			time = 0;
			for(int k=0;k<SAMPLES;k++){

			
			t1 = System.currentTimeMillis();
			
			m.enterPrivateMemory(Monitor.S_SIZE, sensorCalibrate);
			
			for(int i=0; i<Monitor.NO_OF_SENSORS; i++){
				sensorMeassure.setIdx(i);
				m.enterPrivateMemory(Monitor.S_SIZE, sensorMeassure);	
			}
			
			//System.out.println(meassurements[0].average);
			
			t2 = System.currentTimeMillis();
			time = time + (t2 - t1);
			
			//System.out.println("Meassure elapsed time: "+ time);

			
			
			//System.out.println(meassurements[0].average);

			/*
			 * Put here logic to be performed after reading of sensors is complete
			 */

//					System.out.println("Array references: " + AASTORE_COUNT);
//					AASTORE_COUNT = 0;
//					System.out.println("Static references: " + PUTSTATIC_COUNT);
//					PUTSTATIC_COUNT = 0;
//					System.out.println("Field references: " + PUTFIELD_COUNT);
//					PUTFIELD_COUNT = 0;
//
//					waitForNextPeriod();
//					
				}
		
		double total = (time/SAMPLES);
		System.out.println("Meassure time: "+ total);
		//System.out.println("Meassure time: "+ time);
		
	}
	
	public static void main (String args[]){
		
		Monitor myMonitor = new Monitor();
		myMonitor.run();
	}
	
	/*
	 * Just a helper method to avoid writing System.out... every time 
	 * we want to print something...
	 */
	public static void print(int s){
		System.out.println(s);
	}
}